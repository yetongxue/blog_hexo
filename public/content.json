[{"title":"HttpUtil工具类","date":"2017-01-07T16:55:44.000Z","path":"httpUtil/","text":"HttpUtil工具类使用HttpClients 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247import java.io.IOException;import java.io.InputStream;import java.nio.charset.Charset;import java.security.GeneralSecurityException;import java.security.cert.CertificateException;import java.security.cert.X509Certificate;import java.util.ArrayList;import java.util.List;import java.util.Map;import javax.net.ssl.HostnameVerifier;import javax.net.ssl.SSLContext;import javax.net.ssl.SSLSession;import org.apache.commons.io.IOUtils;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.apache.http.HttpEntity;import org.apache.http.HttpResponse;import org.apache.http.NameValuePair;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.client.utils.HttpClientUtils;import org.apache.http.conn.ssl.SSLConnectionSocketFactory;import org.apache.http.conn.ssl.TrustStrategy;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;import org.apache.http.message.BasicNameValuePair;import org.apache.http.ssl.SSLContextBuilder;import org.apache.http.util.EntityUtils;import com.fasterxml.jackson.databind.ObjectMapper;import com.yeahka.loan.yunxin.constant.YunXinConstant;import com.yeahka.util.JsonUtil;public class YunXinHttpUtil &#123; private static final Log log = LogFactory.getLog(YunXinHttpUtil.class); private static PoolingHttpClientConnectionManager connMgr; private static RequestConfig requestConfig; private static final int MAX_TIMEOUT = 30000; static &#123; // 设置连接池 connMgr = new PoolingHttpClientConnectionManager(); // 设置连接池大小 connMgr.setMaxTotal(100); connMgr.setDefaultMaxPerRoute(connMgr.getMaxTotal()); RequestConfig.Builder configBuilder = RequestConfig.custom(); // 设置连接超时 configBuilder.setConnectTimeout(MAX_TIMEOUT); // 设置读取超时 configBuilder.setSocketTimeout(MAX_TIMEOUT); // 设置从连接池获取连接实例的超时 configBuilder.setConnectionRequestTimeout(MAX_TIMEOUT); // 在提交请求之前 测试连接是否可用 // configBuilder.setValidateAfterInactivity(true); requestConfig = configBuilder.build(); &#125; /** * 发送 GET 请求（HTTP/HTTPS），K-V形式 * * @param url * @param params * @return */ public static String doGet(String url, Map&lt;String, Object&gt; params) &#123; String apiUrl = url; CloseableHttpClient httpClient = null; if(url.startsWith(\"https:\"))&#123; httpClient = HttpClients.custom() .setSSLSocketFactory(createSSLConnSocketFactory()) .setConnectionManager(connMgr) .setDefaultRequestConfig(requestConfig).build(); &#125;else&#123; httpClient = HttpClients.createDefault(); &#125; StringBuffer param = new StringBuffer(); int i = 0; for (String key : params.keySet()) &#123; if (i == 0) param.append(\"?\"); else param.append(\"&amp;\"); param.append(key).append(\"=\").append(params.get(key)); i++; &#125; apiUrl += param; String result = null; try &#123; HttpGet httpPost = new HttpGet(apiUrl); HttpResponse response = httpClient.execute(httpPost); int statusCode = response.getStatusLine().getStatusCode(); System.out.println(\"执行状态码 : \" + statusCode); HttpEntity entity = response.getEntity(); if (entity != null) &#123; InputStream instream = entity.getContent(); result = IOUtils.toString(instream, \"UTF-8\"); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (httpClient != null) &#123; HttpClientUtils.closeQuietly(httpClient); &#125; &#125; log.info(\"request to : &#123;\"+apiUrl+\"&#125; , param : &#123;\"+param.toString()+\"&#125; , result : &#123;\"+result+\"&#125;\"); return result; &#125; /** * 发送 POST 请求（HTTP/HTTPS），K-V形式 * * @param url * API接口URL * @param params * 参数map * @return */ public static String doPost(String url, Map&lt;String, Object&gt; params) &#123; CloseableHttpClient httpClient = null; String httpStr = null; HttpPost httpPost = null; CloseableHttpResponse response = null; if(url.startsWith(\"https:\"))&#123; httpClient = HttpClients.custom() .setSSLSocketFactory(createSSLConnSocketFactory()) .setConnectionManager(connMgr) .setDefaultRequestConfig(requestConfig).build(); httpPost = new HttpPost(url); &#125;else&#123; httpClient = HttpClients.createDefault(); httpPost = new HttpPost(url); &#125; try &#123; httpPost.setConfig(requestConfig); List&lt;NameValuePair&gt; pairList = new ArrayList&lt;NameValuePair&gt;(); for (Map.Entry&lt;String, Object&gt; entry : params.entrySet()) &#123; NameValuePair pair = new BasicNameValuePair(entry.getKey(), entry.getValue().toString()); pairList.add(pair); &#125; httpPost.setEntity(new UrlEncodedFormEntity(pairList, Charset .forName(\"UTF-8\"))); response = httpClient.execute(httpPost); System.out.println(response.toString()); HttpEntity entity = response.getEntity(); httpStr = EntityUtils.toString(entity, \"UTF-8\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (response != null) &#123; try &#123; EntityUtils.consume(response.getEntity()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return httpStr; &#125; /** * 发送 POST 请求（HTTP/HTTPS），JSON形式 * * @param url * @param json * json对象 * @return */ public static String doPost(String url,Object obj) &#123; CloseableHttpClient httpClient = null; String httpStr = null; HttpPost httpPost = null; CloseableHttpResponse response = null; if(url.startsWith(\"https:\"))&#123; httpClient = HttpClients.custom() .setSSLSocketFactory(createSSLConnSocketFactory()) .setConnectionManager(connMgr) .setDefaultRequestConfig(requestConfig).build(); httpPost = new HttpPost(url); &#125;else&#123; httpClient = HttpClients.createDefault(); httpPost = new HttpPost(url); &#125; try &#123; String json = JsonUtil.obj2json(obj); log.info(json); ObjectMapper mapper = new ObjectMapper(); httpPost.setConfig(requestConfig); httpPost.setHeader(\"Content-Type\", \"application/json\"); httpPost.setHeader(\"MerId\", YunXinConstant.merId); httpPost.setHeader(\"SecretKey\", YunXinConstant.secretKey); httpPost.setHeader(\"SignedMsg\",getSignMsg(mapper.writeValueAsString(obj))); StringEntity stringEntity = new StringEntity(json,\"UTF-8\");// 解决中文乱码问题 stringEntity.setContentEncoding(\"UTF-8\"); stringEntity.setContentType(\"application/json\"); httpPost.setEntity(stringEntity); response = httpClient.execute(httpPost); HttpEntity entity = response.getEntity(); httpStr = EntityUtils.toString(entity, \"UTF-8\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (response != null) &#123; try &#123; EntityUtils.consume(response.getEntity()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return httpStr; &#125; private static String getSignMsg(String msg)&#123; RsaSignUtils utl = new RsaSignUtils(YunXinConstant.privateKeyPath,YunXinConstant.privateCertPassword); return utl.generate(msg); &#125; /** * 创建SSL安全连接 * * @return */ private static SSLConnectionSocketFactory createSSLConnSocketFactory() &#123; SSLConnectionSocketFactory sslsf = null; try &#123; SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial( null, new TrustStrategy() &#123; public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; return true; &#125; &#125;).build(); sslsf = new SSLConnectionSocketFactory(sslContext, new HostnameVerifier() &#123; public boolean verify(String hostname, SSLSession session) &#123; // TODO Auto-generated method stub return false; &#125; &#125;); &#125; catch (GeneralSecurityException e) &#123; e.printStackTrace(); &#125; return sslsf; &#125;&#125;","tags":[{"name":"工具类","slug":"工具类","permalink":"https://yetongxue.github.io/tags/工具类/"},{"name":"HttpUtil","slug":"HttpUtil","permalink":"https://yetongxue.github.io/tags/HttpUtil/"}]},{"title":"JsonUtil工具类","date":"2017-01-07T15:55:44.000Z","path":"jsonUtil/","text":"基于jackson的json和object相互转换的工具类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266import java.io.IOException;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Map.Entry;import org.apache.commons.lang3.StringUtils;import org.springframework.util.CollectionUtils;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.core.type.TypeReference;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.ObjectMapper;/*** 基于jackson的json和object相互转换的工具类* @author * @date 2017年6月21日 上午10:00:23*/public final class JsonUtil &#123; /** 私有构造 单例 */ private JsonUtil()&#123; &#125; private static ObjectMapper objectMapper = null; static &#123; // 将objectMapper 设置为全局静态缓存，提高调用效率 objectMapper = new ObjectMapper(); objectMapper.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")); &#125; /** 供外部调用 ObjectMapper */ public static ObjectMapper getObjectMapper() &#123; return objectMapper; &#125; /** * json串转对象 * @Description * @param jsonStr * @param clazz * @return */ public static &lt;T&gt; T json2obj(String jsonStr, Class&lt;T&gt; clazz) &#123; if (StringUtils.isEmpty(jsonStr)) &#123; return null; &#125; T t = null; try &#123; t = objectMapper.readValue(jsonStr, clazz); &#125; catch (IOException e) &#123; &#125; return t; &#125; /** * json串转map对象,前提是被转换的json串value为多组k-v * &#123;\"zhangjiajie\":&#123;\"price\":\"fixed\",\"type\":\"mountain\"&#125;,\"jiuzhaigou\":&#123;\"price\":\"fixed\",\"type\":\"mountain\"&#125;&#125; * @Description * @param jsonStr * @param clazz * @return Map */ public static &lt;T&gt; Map&lt;String, T&gt; json2map(String jsonStr, Class&lt;T&gt; clazz) &#123; if (StringUtils.isEmpty(jsonStr)) &#123; return null; &#125; Map&lt;String, Map&lt;String, Object&gt;&gt; map = null; try &#123; map = objectMapper.readValue(jsonStr, new TypeReference&lt;Map&lt;String, T&gt;&gt;() &#123; &#125;); &#125; catch (IOException e) &#123; &#125; if (CollectionUtils.isEmpty(map)) &#123; return null; &#125; Map&lt;String, T&gt; result = new HashMap&lt;String, T&gt;(); for (Entry&lt;String, Map&lt;String, Object&gt;&gt; entry : map.entrySet()) &#123; result.put(entry.getKey(), map2pojo(entry.getValue(), clazz)); &#125; return result; &#125; /** * json转list对象 * @Description * @param jsonStr * @param clazz * @return List */ public static &lt;T&gt; List&lt;T&gt; json2list(String jsonStr, Class&lt;T&gt; clazz) &#123; if (StringUtils.isEmpty(jsonStr)) &#123; return null; &#125; List&lt;Map&lt;String, Object&gt;&gt; list = null; try &#123; list = objectMapper.readValue(jsonStr, new TypeReference&lt;List&lt;T&gt;&gt;() &#123; &#125;); &#125; catch (IOException e) &#123; &#125; // 非空校验 if (CollectionUtils.isEmpty(list)) &#123; return null; &#125; List&lt;T&gt; result = new ArrayList&lt;T&gt;(); for (Map&lt;String, Object&gt; map : list) &#123; result.add(map2pojo(map, clazz)); &#125; return result; &#125; /** * 获取json串的某个键对应的值 * @Description * @param jsonSrc * @param jsonKey * @return */ public static String getJsonValue(String jsonSrc, String jsonKey) &#123; if (StringUtils.isEmpty(jsonSrc) || StringUtils.isEmpty(jsonKey)) &#123; return null; &#125; JsonNode node = json2obj(jsonSrc, JsonNode.class); if(node == null) &#123; return null; &#125; // 获取jsonKey数据 JsonNode dataNode = node.get(jsonKey); if (null == dataNode) &#123; return null; &#125; return dataNode.toString(); &#125; /** * 对象转json串,维持基本类型,空值返回null * 示例 * &#123;\"name\":\"alex\",\"age\":20,\"address\":null,\"score\":[&#123;\"subject\":\"math\",\"score\":98&#125;,&#123;\"subject\":\"art\",\"score\":50&#125;]&#125; * @Description * @param obj * @return */ public static String obj2json(Object obj) &#123; if (obj == null) &#123; return null; &#125; String jsonResult = null; try &#123; jsonResult = objectMapper.writeValueAsString(obj); &#125; catch (JsonProcessingException e) &#123; &#125; return jsonResult; &#125; /** * 一般对象转JsonNode * @Description * @param obj * @return */ public static JsonNode obj2node(Object obj) &#123; if (null == obj) &#123; return null; &#125; JsonNode node = null; try &#123; node = objectMapper.readTree(obj2json(obj)); &#125; catch (IOException e) &#123; &#125; return node; &#125; public static &lt;T&gt; T obj2T(Object obj, Class&lt;T&gt; clazz) &#123; if (null == obj) &#123; return null; &#125; T t = null; try &#123; t = objectMapper.readValue(obj2json(obj), clazz); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return t; &#125; /** * map convert to javaBean */ private static &lt;T&gt; T map2pojo(@SuppressWarnings(\"rawtypes\")Map map, Class&lt;T&gt; clazz) &#123; return objectMapper.convertValue(map, clazz); &#125; &#125;","tags":[{"name":"工具类","slug":"工具类","permalink":"https://yetongxue.github.io/tags/工具类/"},{"name":"jsonUtil","slug":"jsonUtil","permalink":"https://yetongxue.github.io/tags/jsonUtil/"}]},{"title":"常见异常","date":"2017-01-07T14:55:44.000Z","path":"FAQ/","text":"1、spring boot启动报异常12Exception in thread \"main\" java.lang.UnsupportedClassVersionError: org/springframework/boot/loader/JarLauncher : Unsupported major.minor version 52.0 解决办法： 换成jdk1.8 pom.xml添加:1234&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&lt;/plugin&gt; 2、解决svn的working copy locked并且cleanup恢复不能的情况","tags":[{"name":"常见异常","slug":"常见异常","permalink":"https://yetongxue.github.io/tags/常见异常/"}]},{"title":"签名用的工具箱","date":"2017-01-07T14:55:44.000Z","path":"signUtil/","text":"签名算法工具，签名生成的步骤如下： 第一步，设所有发送或者接收到的数据为集合M，将集合M内非空参数值的参数按照参数名ASCII码从小到大排序（字典序），使用URL键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串stringA。 第二步，在stringA最后拼接上key得到stringSignTemp字符串，并对stringSignTemp进行MD5运算，再将得到的字符串所有字符转换为大写，得到sign值signValue。 特别注意以下重要规则： ◆ 参数名ASCII码从小到大排序（字典序）； ◆ 如果参数的值为空不参与签名； ◆ 参数名区分大小写； ◆ 验证调用返回或主动通知签名时，传送的sign参数不参与签名，将生成的签名与该sign值作校验。 ◆ key值由互金端提供； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138import java.io.StringReader;import java.net.URLEncoder;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.SortedMap;import java.util.TreeMap;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;import org.xml.sax.InputSource;/*** ClassName:SignUtils&lt;/br&gt;* Function: 签名用的工具箱&lt;/br&gt;* Date: 2017-2-27 下午3:22:33 &lt;/br&gt;* &lt;功能详细描述&gt;签名算法&lt;/br&gt;* @author */public class SignUtils &#123; public static void main(String[] args) &#123; String key = \"CvRu8Dydbe7SETJoqh5wQYBp4PnZxigz\"; SortedMap&lt;String,String&gt; params = new TreeMap&lt;String,String&gt;(); params.put(\"orderId\", \"1112233\"); params.put(\"merchantId\", \"3700603014\"); params.put(\"applyAmount\", \"1000000\"); params.put(\"sign\", \"sdfsdf\"); String sign = getSign(params,key);//签名 System.out.println(\"sign:\"+sign.toUpperCase()); params.put(\"sign\", sign.toUpperCase()); System.out.println(\"sign:\"+checkParam(params,key));//验证 &#125; /** &lt;一句话功能简述&gt; * &lt;功能详细描述&gt;验证返回参数 * @param params * @param key * @return * @see [类、类#方法、类#成员] */ public static boolean checkParam(Map&lt;String,String&gt; params,String key)&#123; boolean result = false; if(params.containsKey(\"sign\"))&#123; String sign = params.get(\"sign\"); params.remove(\"sign\"); params = paraFilter(params); StringBuilder buf = new StringBuilder((params.size() +1) * 10); SignUtils.buildPayParams(buf,params,false); String preStr = buf.toString(); String signRecieve = MD5.sign(preStr, \"&amp;key=\" + key, \"utf-8\"); System.out.println(signRecieve); result = sign.equalsIgnoreCase(signRecieve); &#125; return result; &#125; /** * 获取签名 * @param map 对象 * @param key 密匙 * @return 签名 */ public static String getSign(SortedMap&lt;String,String&gt; map,String key)&#123; Map&lt;String, String&gt; params = SignUtils.paraFilter(map); StringBuilder buf = new StringBuilder((params.size() + 1) * 10); SignUtils.buildPayParams(buf, params, false); String preStr = buf.toString(); System.out.println(preStr); String sign = MD5.sign(preStr, \"&amp;key=\" + key, \"utf-8\").toUpperCase(); return sign; &#125; /** * 过滤参数:过滤掉sArray中value为空和key为sign的键值对 * @param sArray * @return */ public static Map&lt;String, String&gt; paraFilter(Map&lt;String, String&gt; sArray) &#123; Map&lt;String, String&gt; result = new HashMap&lt;String, String&gt;(sArray.size()); if (sArray == null || sArray.size() &lt;= 0) &#123; return result; &#125; for (String key : sArray.keySet()) &#123; String value = sArray.get(key); if (value == null || value.equals(\"\") || key.equalsIgnoreCase(\"sign\")) &#123; continue; &#125; result.put(key, value); &#125; return result; &#125; /** * 将集合M内非空参数值的参数按照参数名ASCII码从小到大排序（字典序），使用URL键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串stringA * @param sb 返回的字符串 * @param payParams 集合M * @param encoding 是否需要经过UTF-8编码：true-需要 false-不需要 */ public static void buildPayParams(StringBuilder sb,Map&lt;String, String&gt; payParams,boolean encoding)&#123; List&lt;String&gt; keys = new ArrayList&lt;String&gt;(payParams.keySet()); Collections.sort(keys); for(String key : keys)&#123; sb.append(key).append(\"=\"); if(encoding)&#123; sb.append(urlEncode(payParams.get(key))); &#125;else&#123; sb.append(payParams.get(key)); &#125; sb.append(\"&amp;\"); &#125; sb.setLength(sb.length() - 1); &#125; public static String urlEncode(String str)&#123; try &#123; return URLEncoder.encode(str, \"UTF-8\"); &#125; catch (Throwable e) &#123; return str; &#125; &#125; public static Element readerXml(String body,String encode) throws DocumentException &#123; SAXReader reader = new SAXReader(false); InputSource source = new InputSource(new StringReader(body)); source.setEncoding(encode); Document doc = reader.read(source); Element element = doc.getRootElement(); return element; &#125;&#125;","tags":[{"name":"签名","slug":"签名","permalink":"https://yetongxue.github.io/tags/签名/"},{"name":"工具类","slug":"工具类","permalink":"https://yetongxue.github.io/tags/工具类/"}]}]