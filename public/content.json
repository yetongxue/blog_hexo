[{"title":"常见异常","date":"2018-06-14T03:57:23.728Z","path":"常见异常/","text":"1、spring boot启动报异常Exception in thread “main” java.lang.UnsupportedClassVersionError: org/springframework/boot/loader/JarLauncher : Unsupported major.minor version 52.0 解决办法： 换成jdk1.8 pom.xml添加: &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;/plugin&gt; 2、解决svn的working copy locked并且cleanup恢复不能的情况","tags":[]},{"title":"签名用的工具","date":"2018-06-14T03:57:23.718Z","path":"签名用的工具/","text":"import java.io.StringReader; import java.net.URLEncoder; import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.SortedMap; import java.util.TreeMap; import org.dom4j.Document; import org.dom4j.DocumentException; import org.dom4j.Element; import org.dom4j.io.SAXReader; import org.xml.sax.InputSource; /** * ClassName:SignUtils&lt;/br&gt; * Function: 签名用的工具箱&lt;/br&gt; * Date: 2017-2-27 下午3:22:33 &lt;/br&gt; * &lt;功能详细描述&gt;签名算法&lt;/br&gt; * 签名生成的通用步骤如下：&lt;/br&gt; * 第一步，设所有发送或者接收到的数据为集合M，将集合M内非空参数值的参数按照参数名ASCII码从小到大排序（字典序），使用URL键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串stringA。&lt;/br&gt; * 第二步，在stringA最后拼接上key得到stringSignTemp字符串，并对stringSignTemp进行MD5运算，再将得到的字符串所有字符转换为大写，得到sign值signValue。&lt;/br&gt; * 特别注意以下重要规则：&lt;/br&gt; * ◆ 参数名ASCII码从小到大排序（字典序）；&lt;/br&gt; * ◆ 如果参数的值为空不参与签名；&lt;/br&gt; * ◆ 参数名区分大小写；&lt;/br&gt; * ◆ 验证调用返回或主动通知签名时，传送的sign参数不参与签名，将生成的签名与该sign值作校验。&lt;/br&gt; * ◆ key值由互金端提供；&lt;/br&gt; * @author */ public class SignUtils { public static void main(String[] args) { String key = &quot;CvRu8Dydbe7SETJoqh5wQYBp4PnZxigz&quot;; SortedMap&lt;String,String&gt; params = new TreeMap&lt;String,String&gt;(); params.put(&quot;orderId&quot;, &quot;1112233&quot;); params.put(&quot;merchantId&quot;, &quot;3700603014&quot;); params.put(&quot;applyAmount&quot;, &quot;1000000&quot;); params.put(&quot;sign&quot;, &quot;sdfsdf&quot;); String sign = getSign(params,key);//签名 System.out.println(&quot;sign:&quot;+sign.toUpperCase()); params.put(&quot;sign&quot;, sign.toUpperCase()); System.out.println(&quot;sign:&quot;+checkParam(params,key));//验证 } /** &lt;一句话功能简述&gt; * &lt;功能详细描述&gt;验证返回参数 * @param params * @param key * @return * @see [类、类#方法、类#成员] */ public static boolean checkParam(Map&lt;String,String&gt; params,String key){ boolean result = false; if(params.containsKey(&quot;sign&quot;)){ String sign = params.get(&quot;sign&quot;); params.remove(&quot;sign&quot;); params = paraFilter(params); StringBuilder buf = new StringBuilder((params.size() +1) * 10); SignUtils.buildPayParams(buf,params,false); String preStr = buf.toString(); String signRecieve = MD5.sign(preStr, &quot;&amp;key=&quot; + key, &quot;utf-8&quot;); System.out.println(signRecieve); result = sign.equalsIgnoreCase(signRecieve); } return result; } /** * 获取签名 * @param map 对象 * @param key 密匙 * @return 签名 */ public static String getSign(SortedMap&lt;String,String&gt; map,String key){ Map&lt;String, String&gt; params = SignUtils.paraFilter(map); StringBuilder buf = new StringBuilder((params.size() + 1) * 10); SignUtils.buildPayParams(buf, params, false); String preStr = buf.toString(); System.out.println(preStr); String sign = MD5.sign(preStr, &quot;&amp;key=&quot; + key, &quot;utf-8&quot;).toUpperCase(); return sign; } /** * 过滤参数:过滤掉sArray中value为空和key为sign的键值对 * @param sArray * @return */ public static Map&lt;String, String&gt; paraFilter(Map&lt;String, String&gt; sArray) { Map&lt;String, String&gt; result = new HashMap&lt;String, String&gt;(sArray.size()); if (sArray == null || sArray.size() &lt;= 0) { return result; } for (String key : sArray.keySet()) { String value = sArray.get(key); if (value == null || value.equals(&quot;&quot;) || key.equalsIgnoreCase(&quot;sign&quot;)) { continue; } result.put(key, value); } return result; } /** * 将集合M内非空参数值的参数按照参数名ASCII码从小到大排序（字典序），使用URL键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串stringA * @param sb 返回的字符串 * @param payParams 集合M * @param encoding 是否需要经过UTF-8编码：true-需要 false-不需要 */ public static void buildPayParams(StringBuilder sb,Map&lt;String, String&gt; payParams,boolean encoding){ List&lt;String&gt; keys = new ArrayList&lt;String&gt;(payParams.keySet()); Collections.sort(keys); for(String key : keys){ sb.append(key).append(&quot;=&quot;); if(encoding){ sb.append(urlEncode(payParams.get(key))); }else{ sb.append(payParams.get(key)); } sb.append(&quot;&amp;&quot;); } sb.setLength(sb.length() - 1); } public static String urlEncode(String str){ try { return URLEncoder.encode(str, &quot;UTF-8&quot;); } catch (Throwable e) { return str; } } public static Element readerXml(String body,String encode) throws DocumentException { SAXReader reader = new SAXReader(false); InputSource source = new InputSource(new StringReader(body)); source.setEncoding(encode); Document doc = reader.read(source); Element element = doc.getRootElement(); return element; } }","tags":[]}]